<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Online Reinforcement Learning | Isaac Kargar</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Online Reinforcement Learning" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In this post, I try to summarize some interesting online RL algorithms." />
<meta property="og:description" content="In this post, I try to summarize some interesting online RL algorithms." />
<link rel="canonical" href="https://kargarisaac.github.io/blog/rl/2020/06/15/online-rl.html" />
<meta property="og:url" content="https://kargarisaac.github.io/blog/rl/2020/06/15/online-rl.html" />
<meta property="og:site_name" content="Isaac Kargar" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-15T00:00:00-05:00" />
<script type="application/ld+json">
{"description":"In this post, I try to summarize some interesting online RL algorithms.","@type":"BlogPosting","headline":"Online Reinforcement Learning","url":"https://kargarisaac.github.io/blog/rl/2020/06/15/online-rl.html","datePublished":"2020-06-15T00:00:00-05:00","dateModified":"2020-06-15T00:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://kargarisaac.github.io/blog/rl/2020/06/15/online-rl.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://kargarisaac.github.io/blog/feed.xml" title="Isaac Kargar" /><link rel="shortcut icon" type="image/x-icon" href="/blog/images/favicon.ico"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Online Reinforcement Learning | Isaac Kargar</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Online Reinforcement Learning" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In this post, I try to summarize some interesting online RL algorithms." />
<meta property="og:description" content="In this post, I try to summarize some interesting online RL algorithms." />
<link rel="canonical" href="https://kargarisaac.github.io/blog/rl/2020/06/15/online-rl.html" />
<meta property="og:url" content="https://kargarisaac.github.io/blog/rl/2020/06/15/online-rl.html" />
<meta property="og:site_name" content="Isaac Kargar" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-15T00:00:00-05:00" />
<script type="application/ld+json">
{"description":"In this post, I try to summarize some interesting online RL algorithms.","@type":"BlogPosting","headline":"Online Reinforcement Learning","url":"https://kargarisaac.github.io/blog/rl/2020/06/15/online-rl.html","datePublished":"2020-06-15T00:00:00-05:00","dateModified":"2020-06-15T00:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://kargarisaac.github.io/blog/rl/2020/06/15/online-rl.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

<link href="https://unpkg.com/@primer/css/dist/primer.css" rel="stylesheet" />
<link rel="stylesheet" href="//use.fontawesome.com/releases/v5.0.7/css/all.css"><link type="application/atom+xml" rel="alternate" href="https://kargarisaac.github.io/blog/feed.xml" title="Isaac Kargar" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head><body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog/">Isaac Kargar</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/blog/about/">About Me</a><a class="page-link" href="/blog/search/">Search</a><a class="page-link" href="/blog/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Online Reinforcement Learning</h1><p class="page-description">In this post, I try to summarize some interesting online RL algorithms.</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2020-06-15T00:00:00-05:00" itemprop="datePublished">
        Jun 15, 2020
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      18 min read
    
</span></p>

    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul class="section-nav">
<li class="toc-entry toc-h1"><a href="#online-reinforcement-learning">Online Reinforcement Learning</a></li>
<li class="toc-entry toc-h1"><a href="#single-agent">Single agent</a>
<ul>
<li class="toc-entry toc-h3"><a href="#dqn">DQN</a></li>
<li class="toc-entry toc-h3"><a href="#reinforce">REINFORCE</a></li>
<li class="toc-entry toc-h3"><a href="#a2c">A2C</a></li>
<li class="toc-entry toc-h3"><a href="#a3c">A3C</a></li>
<li class="toc-entry toc-h3"><a href="#ppo">PPO</a></li>
<li class="toc-entry toc-h3"><a href="#ddpg">DDPG</a></li>
<li class="toc-entry toc-h3"><a href="#sac">SAC</a></li>
<li class="toc-entry toc-h3"><a href="#ape-x">Ape-X</a></li>
<li class="toc-entry toc-h3"><a href="#r2d2">R2D2</a></li>
<li class="toc-entry toc-h3"><a href="#impala">IMPALA</a></li>
<li class="toc-entry toc-h3"><a href="#never-give-up">Never Give-Up</a></li>
<li class="toc-entry toc-h3"><a href="#agent57">Agent57</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#multi-agent">Multi-Agent</a>
<ul>
<li class="toc-entry toc-h2"><a href="#value-based-methods">VALUE-BASED METHODS</a>
<ul>
<li class="toc-entry toc-h3"><a href="#vdn">VDN</a></li>
<li class="toc-entry toc-h3"><a href="#qmix">QMIX</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#actor-critic-based-methods">ACTOR-CRITIC BASED METHODS</a>
<ul>
<li class="toc-entry toc-h3"><a href="#maddpg">MADDPG</a></li>
<li class="toc-entry toc-h3"><a href="#coma">COMA</a></li>
</ul>
</li>
</ul>
</li>
</ul><h1 id="online-reinforcement-learning">
<a class="anchor" href="#online-reinforcement-learning" aria-hidden="true"><span class="octicon octicon-link"></span></a>Online Reinforcement Learning</h1>

<p>In this post I will overview different single and multi-agent online Reinforcement Learning (RL) algorithms. By <strong>online</strong> I mean the algorithms that can interact with an environment and collect data, in contrast to offline RL. I will update this post and add algorithms periodically.</p>

<p><img src="/blog/images/posts_images/rl-series/rl-diagram.png" alt="RL diagram"> <em>RL diagram</em></p>

<p>Here are some resources to learn more about RL!</p>

<ul>
  <li>
    <p>David Silver’s <a href="https://www.youtube.com/playlist?list=PLzuuYNsE1EZAXYR4FJ75jcJseBmo4KQ9-">course</a></p>
  </li>
  <li>
    <p>CS287 at UC Berkeley - Advanced Robotics <a href="https://www.youtube.com/playlist?list=PLwRJQ4m4UJjNBPJdt8WamRAt4XKc639wF">course</a> - Instructor: Pieter Abbeel</p>
  </li>
  <li>
    <p>CS 285 at UC Berkeley - Deep Reinforcement Learning <a href="http://rail.eecs.berkeley.edu/deeprlcourse/">course</a> - Instructor: Sergey Levine</p>
  </li>
  <li>
    <p>CS234 at Stanford - Reinforcement Learning <a href="http://web.stanford.edu/class/cs234/index.html">course</a> - Instructor: Emma Brunskill</p>
  </li>
  <li>
    <p>CS885 at University of Waterloo - Reinforcement Learning <a href="https://www.youtube.com/playlist?list=PLdAoL1zKcqTXFJniO3Tqqn6xMBBL07EDc">course</a> - Instructor: Pascal Poupart</p>
  </li>
  <li>
    <p>Arthur Juliani’s <a href="https://medium.com/@awjuliani">posts</a></p>
  </li>
  <li>
    <p>Jonathan Hui’s <a href="https://medium.com/@jonathan_hui/rl-deep-reinforcement-learning-series-833319a95530">posts</a></p>
  </li>
  <li>
    <p>A Free <a href="https://simoninithomas.github.io/deep-rl-course/">course</a> in Deep Reinforcement Learning from beginner to expert by Thomas Simonni</p>
  </li>
</ul>

<h1 id="single-agent">
<a class="anchor" href="#single-agent" aria-hidden="true"><span class="octicon octicon-link"></span></a>Single agent</h1>

<h3 id="dqn">
<a class="anchor" href="#dqn" aria-hidden="true"><span class="octicon octicon-link"></span></a>DQN</h3>

<p>We will take a look at DQN with experience replay buffer and the target network.</p>

<p>DQN is a value-based method. It means that we try to learn a value function and then use it to achieve the policy. In DQN we use a neural network as a function approximator for our value function. It gets the state as input and outputs the value for different actions in that state. These values are not limited to be between zero and one, like probabilities, and can have other values based on the environment and the reward function we define.</p>

<p>DQN is an off-policy method which means that we are using data from old policies, the data that we gather in every interaction with the environment and save it in the experience replay buffer, to sample from it later and train the network. The size of the replay buffer should be large enough to reduce the $i.i.d$ property between data that we sample from it.</p>

<p>To use DQN, the action should be discrete. We can use it for continuous action spaces by discretizing the action space, but it’s better to use other techniques that can handle continuous action spaces such as Policy Gradients.
First, let’s see the algorithm’s sudo code:</p>

<p><img src="/blog/images/posts_images/rl-series/dqn.png" alt="DQN algorithm" title="DQN algorithm"></p>

<p>In this algorithm, we have experience replay buffer and a target network with a different set of parameters that will be updated every $C$ steps. These tricks help to get a better and more stable method rather than pure DQN. There are a lot of improvements for DQN and we will see some of them in the next posts too.</p>

<p>First, we initialize the weights of both networks and then start from the initial state s and take action a with epsilon-greedy policy. In the epsilon-greedy policy, we select an action a randomly or using the Q-network. Then we execute the selected action and get the next state, reward, and the done values from the environment and save them in our replay buffer. Then we sample a random batch from the replay buffer and calculate target based on the Bellman equation in the above picture and use MSE loss and gradient descent to update the network weights. We will update the weights of our target network every $C$ steps.</p>

<p>In the training procedure, we use epsilon decay. It means that we consider a big value for epsilon, such as $1$. Then during the training procedure, as we go forward, we reduce its value to something like $0.02$ or $0.05$, based on the environment. It will help the agent to do more exploration in the first steps and learn more about the environment. It’s better to have some exploration always. That’s a trade-off between exploration-exploitation.
In test time, we have to use a greedy policy. It means we have to select the action with the highest value, not randomly anymore (set epsilon to zero actually).</p>

<h3 id="reinforce">
<a class="anchor" href="#reinforce" aria-hidden="true"><span class="octicon octicon-link"></span></a>REINFORCE</h3>

<p>REINFORCE is a Monte-Carlo Policy Gradient (PG) method. In PGs, we try to find a policy to map the state into action directly.</p>

<p>In value-based methods, we find a value function and use it to find the optimal policy. Policy gradient methods can be used for stochastic policies and continuous action spaces. If you want to use DQN for continuous action spaces, you have to discretize your action space. This will reduce the performance and if the number of actions is high, it will be difficult and impossible. But REINFORCE algorithms can be used for discrete or continuous action spaces. They are on-policy because they use the samples gathered from the current policy.</p>

<p>There are different versions of REINFORCE. The first one is without a baseline. It is as follows:</p>

<p><img src="/blog/images/posts_images/rl-series/reinforce.png" alt="reinforce algorithm" title="from Sutton Barto book: Introduction to Reinforcement Learning"></p>

<p>In this version, we consider a policy (here a neural network) and initialize it with some random weights. Then we play for one episode and after that, we calculate discounted reward from each time step towards the end of the episode. This discounted reward (G in the above sudo code) will be multiplied by the gradient. This G is different based on the environment and the reward function we define. For example, consider that we have three actions. The first action is a bad action and the other two actions are some good actions that will cause more future discounted rewards. If we have three positive G values for three different actions, we are pushing the network towards all of them. Actually, we push the network towards action number one slightly and towards others more. Now consider we have one negative G value for the first action and two G values for the other two actions. Here we are pushing the network far from the first action and towards the other two actions. You see?! the value of G and its sign is important. It guides our gradient direction and its step size. To solve such problems, one way is to use baseline. This will reduce the variance and accelerate the learning procedure. For example, subtract the value of the state from it, or normalize it with the mean and variance of the discounted reward of the current episode. You can see the sudo code for REINFORCE with baseline in the following picture:</p>

<p><img src="/blog/images/posts_images/rl-series/reinforce2.png" alt="reinforce algorithm" title="from Sutton Barto book: Introduction to Reinforcement Learning"></p>

<p>In this version, first, we initialize the policy and value networks. It is possible to use two separate networks or a multi-head network with a shared part. Then we play an episode and calculate the discounted reward from every step until the end of the episode (reward to go). Then subtract the value (from the learned neural net) for that state from the discounted reward (REINFORCE with baseline) and use it to update the weights of value and policy networks. Then generate another episode and repeat the loop.</p>

<p>In the Sutton&amp;Barto book, they do not consider the above algorithm as actor-critic (another RL algorithm that we will see in the next posts). It learns the value function but it is not used as a critic! I think it is because we do not use the learned value function (critic) in the first term of the policy gradient rescaler (for bootstrapping) to tell us how good is our policy or action in every step or in a batch of actions (in A2C and A3C we do the update every t_max step). In REINFORCE we update the network at the end of each episode.</p>

<p><em>“The REINFORCE method follows directly from the policy gradient theorem. Adding a state-value function as a baseline reduces REINFORCE’s variance without introducing bias. Using the state-value function for bootstrapping introduces bias but is often desirable for the same reason that bootstrapping TD methods are often superior to Monte Carlo methods (substantially reduced variance). The state-value function assigns credit to — critizes — the policy’s action selections, and accordingly the former is termed the critic and the latter the actor, and these overall methods are termed actor–critic methods.
Actor–critic methods are sometimes referred to as advantage actor–critic (“A2C”) methods in the literature.”</em>
[Sutton&amp;Barto — second edition]</p>

<p>I think Monte-Carlo policy gradient and Actor-Critic policy gradient are good names as I saw in the slides of David Silver course.</p>

<p><img src="/blog/images/posts_images/rl-series/reinforce3.png" alt="reinforce algorithm" title="source: https://www.youtube.com/watch?v=KHZVXao4qXs&amp;list=PLqYmG7hTraZDM-OYHWgPebj2MfCFzFObQ&amp;index=7"></p>

<p>I also saw the following slide from the Deep Reinforcement Learning and Control course (CMU 10703) at Carnegie Mellon University:</p>

<p><img src="/blog/images/posts_images/rl-series/reinforce4.png" alt="reinforce algorithm" title="source: https://www.andrew.cmu.edu/course//10-703/slides/Lecture_PG-NatGrad-10-8-2018.pdf"></p>

<p>Here they consider every method that uses value function (V or Q) as actor-critic and if you just consider reward to go in the policy gradient rescaler, it is REINFORCE. The policy evaluation by the value function can be TD or MC.</p>

<p>Summary of the categorization:</p>

<ul>
  <li>
    <p>Vanilla REINFORCE or Policy gradient → we use G as gradient rescaler.</p>
  </li>
  <li>
    <p>REINFORCE with baseline → we use $\frac{G-mean(G)}{std(G)}$ or $(G-V)$ as gradient rescaler. We do not use $V$ in $G$. $G$ is only the reward to go for every step in the episode → $G_t = r_t + \gamma r_{t+1} + … $</p>
  </li>
  <li>
    <p>Actor-Critic → we use $V$ in the first term of gradient rescaler and call it Advantage ($A$):</p>
  </li>
</ul>

<p>$A_t = Q(s_t, a_t) - V(s_t)$</p>

<p>$A_t = r_t + \gamma V_{s_{t+1}} - V_{s_t}$ → for one-step</p>

<p>$A_t = r_t + \gamma r_{t+1} + \gamma^2 V_{s_{t+2}} - V_{s_t}$ → for 2-step</p>

<p>and so on.</p>

<ul>
  <li>In Actor-Critics you can do the update each $N$ step based on your task. This $N$ can be less than an episode.</li>
</ul>

<p>Anyway, let’s continue.</p>

<p>This algorithm can be used for either discrete or continuous action spaces. In discrete action spaces, it will output a probability distribution over action, which means that the activation function of the output layer is a softmax. For exploration-exploitation, it samples from the actions based on their probabilities. Actions with higher probabilities have more chances to be selected.</p>

<p>In continuous action spaces, the output will not have any softmax. Because the output is a mean for a normal distribution. We consider one neuron for each action and it can have any value. In fact, the policy is a normal distribution and we calculate its mean by a neural network. The variance can be fixed or decrease over time or can be learned. You can consider it as a function of the input state, or define it as a parameter that can be learned by gradient descent. If you want to learn the sigma too, you have to consider the number of actions. For example, if we want to map the front view image of a self-driving car into steering and throttle-brake, we have two continuous actions. So we have to have two mean and two variance for these two actions. During training, we sample from this normal distribution for exploration of the environment, but in the test, we only use the mean as action.</p>

<h3 id="a2c">
<a class="anchor" href="#a2c" aria-hidden="true"><span class="octicon octicon-link"></span></a>A2C</h3>

<h3 id="a3c">
<a class="anchor" href="#a3c" aria-hidden="true"><span class="octicon octicon-link"></span></a>A3C</h3>

<h3 id="ppo">
<a class="anchor" href="#ppo" aria-hidden="true"><span class="octicon octicon-link"></span></a>PPO</h3>

<h3 id="ddpg">
<a class="anchor" href="#ddpg" aria-hidden="true"><span class="octicon octicon-link"></span></a>DDPG</h3>

<p>This algorithm is from the <em>“Continuous Control with Deep Reinforcement Learning”</em> <a href="https://arxiv.org/pdf/1509.02971.pdf">paper</a> and uses the ideas from deep q-learning in the continuous action domain and is a model-free method based on the deterministic policy gradient.</p>

<p>In Deterministic Policy Gradient (DPG), for each state, we have one clearly defined action to take (the output of policy is one value for action and for exploration we add a noise, normal noise for example, to the action). But in Stochastic Gradient Descent, we have a distribution over actions (the output of policy is mean and variance of a normal distribution) and sample from that distribution to get the action, for exploration. In another term, in stochastic policy gradient, we have a distribution with mean and variance and we draw a sample from that as an action. When we reduce the variance to zero, the policy will be deterministic.</p>

<p>When the action space is discrete, such as q-learning, we get the max over q-values of all actions and select the best action. But in continuous action spaces, you cannot apply q-learning directly, because in continuous spaces finding the greedy policy requires optimization of $a_t$ at every time-step and would be too slow for large networks and continuous action spaces. Based on the proposed equation in the reference paper, here we approximate <em>max Q(s, a)</em> over actions with <em>Q(a, µ(s))</em>.</p>

<p>In DDPG, they used function approximators, neural nets, for both action-value function $Q$ and deterministic policy function $\mu$. In addition, DDPG uses some techniques for stabilizing training, such as updating the target networks using soft updating for both $\mu$ and $Q$. It also uses batch normalization layers, noise for exploration, and a replay buffer to break temporal correlations.</p>

<p>This algorithm is an actor-critic method and the network structure is as follows:</p>

<p><img src="/blog/images/posts_images/ddpg_post/ddpg_diagram.jpg" alt="DDPG diagram" title="DDPG diagram"></p>

<p>First, the policy network gets the state and outputs the action mean vector. This will be a vector of mean values for different actions. For example, in a self-driving car, there are two continuous actions: steering and acceleration&amp;braking (one continuous value between $-x$ to $x$, the negative values are for braking and positive values are for acceleration). So we will have two mean for these two actions. To consider exploration, we can use Ornstein-Uhlenbeck or normal noise and add it to the action mean vector in the training phase. In the test phase, we can use the mean vector directly without any added noise. Then this action vector will be concatenated with observation and fed into the $Q$ network. The output of the $Q$ network will be one single value as a state-action value. In DQN, because it had discrete action space, we had multiple state-action values for each action, but here because the action space is continuous, we feed the actions into the $Q$ network and get one single value as the state-action value.</p>

<p>Finally, the sudo code for DDPG is as follows:</p>

<p><img src="/blog/images/posts_images/ddpg_post/ddpg_algorithm.jpg" alt="DDPG algorithm" title="DDPG algorithm"></p>

<p>To understand the algorithm better, it’s good to try to implement it and play with its parameters and test it in different environments. Here is a good implementation in PyTorch that you can start with <a href="https://github.com/higgsfield/RL-Adventure-2/blob/master/5.ddpg.ipynb">this</a>.</p>

<p>I also found the Spinningup implementation of DDPG very clear and understandable too. You can find it <a href="https://github.com/openai/spinningup/blob/master/spinup/algos/pytorch/ddpg/ddpg.py">here</a></p>

<p>For POMDP problems, it is possible to use LSTMs or any other RNN layers to get a sequence of observations. It needs a different type of replay buffer for sequential data.</p>

<h3 id="sac">
<a class="anchor" href="#sac" aria-hidden="true"><span class="octicon octicon-link"></span></a>SAC</h3>

<h3 id="ape-x">
<a class="anchor" href="#ape-x" aria-hidden="true"><span class="octicon octicon-link"></span></a>Ape-X</h3>

<h3 id="r2d2">
<a class="anchor" href="#r2d2" aria-hidden="true"><span class="octicon octicon-link"></span></a>R2D2</h3>

<h3 id="impala">
<a class="anchor" href="#impala" aria-hidden="true"><span class="octicon octicon-link"></span></a>IMPALA</h3>

<h3 id="never-give-up">
<a class="anchor" href="#never-give-up" aria-hidden="true"><span class="octicon octicon-link"></span></a>Never Give-Up</h3>

<h3 id="agent57">
<a class="anchor" href="#agent57" aria-hidden="true"><span class="octicon octicon-link"></span></a>Agent57</h3>

<h1 id="multi-agent">
<a class="anchor" href="#multi-agent" aria-hidden="true"><span class="octicon octicon-link"></span></a>Multi-Agent</h1>

<p>In Multi-Agent Reinforcement Learning (MARL)problems, there are several agents who usually have their own private observation and want to take an action based on that observation. This observation is local and different from the full state of the environment in that time-step. The other problem that we face in such environments is the non-stationary problem because all agents are learning and their behavior would be different during training as they learn to act differently.</p>

<p>To solve this problem, the most naive approach is to use single-agent RL algorithms for each agent and treat other agents as part of the environment. Some methods like Independent Q-Learning (IQL) work fine in some multi-agent RL problems in practice but there is no guarantee for them to converge. In IQL, each agent has one separate action-value function that gets the agent’s local observation to select its action based on that. It is also possible to use additional inputs like previous actions as input. Usually, in partially observable environments, we use RNNs to consider a history of several sequential observation-actions.</p>

<p><img src="/blog/images/posts_images/ddpg_post/marl1.png" alt="MARL" title=" source: https://arxiv.org/pdf/1706.05296.pdf "></p>

<p>The other approach is to have a fully centralised method to learn and act in a centralised fashion. We can consider this type as a big single-agent problem. This approach is also valid in some problems that you don’t need decentralised execution. For example for traffic management or traffic light management, it is possible to use such approaches.</p>

<p>There is one more case that is somewhere between the previous two ones: centralised training and decentralised execution. Usually in the training procedure, because we train agents in a simulation environment or in a lab, we have access to the full state and information in the training phase. So it is better to use this knowledge. On the other hand, the learned policy should be decentralised in some environments and agents cannot have access to the full state during the execution phase. So having algorithms to use the available knowledge in the training phase and learn a policy that is not dependent on the full state in the execution time is necessary. Here we focus on the last case.</p>

<p>There are several works that try to propose such an algorithm and can be divided into two groups:</p>

<ul>
  <li>
    <p>value-based methods like Value Decomposition Networks (VDN) and QMIX</p>
  </li>
  <li>
    <p>actor-critic methods like MADDPG and COMA</p>
  </li>
</ul>

<h2 id="value-based-methods">
<a class="anchor" href="#value-based-methods" aria-hidden="true"><span class="octicon octicon-link"></span></a>VALUE-BASED METHODS</h2>

<p>These approaches try to propose a way to be able to use value-based methods like Q-learning and train them in a centralised way and use them for decentralised execution.</p>

<h3 id="vdn">
<a class="anchor" href="#vdn" aria-hidden="true"><span class="octicon octicon-link"></span></a>VDN</h3>

<p>This work proposes a way to have separate action-value functions for multiple agents and learn them by just one shared team reward signal. The joint action-value function is a linear summation of all action-value functions of all agents. Actually, by using a single shared reward signal, it tries to learn decomposed value functions for each agent and use it for decentralised execution.</p>

<p><img src="/blog/images/posts_images/ddpg_post/vdn1.png" alt="VDN" title=" source: https://arxiv.org/pdf/1706.05296.pdf "></p>

<p>Consider a case with 2 agents, the reward would be:</p>

<p><img src="/blog/images/posts_images/ddpg_post/vdn2.png" alt="VDN"></p>

<p>Then the total Q function is:</p>

<p><img src="/blog/images/posts_images/ddpg_post/vdn3.png" alt="VDN"></p>

<p>It is using the same Bellman equation to standard q-learning approach and just replaces Q in that equation with the new Q value.</p>

<h3 id="qmix">
<a class="anchor" href="#qmix" aria-hidden="true"><span class="octicon octicon-link"></span></a>QMIX</h3>

<p>QMIX is somehow an extension to value decomposition networks (VDN) but tries to mix the Q-value of different agents in a nonlinear way. They use global state s_t as input to hypernetworks to generate weights and biases of the mixing network.</p>

<p><img src="/blog/images/posts_images/ddpg_post/qmix1.png" alt="QMIX" title=" source: https://arxiv.org/pdf/1803.11485.pdf"></p>

<p>Here again, the equation to update the weights is the standard Bellman equation in which the Q is replaced with Q_tot in the above figure.</p>

<h2 id="actor-critic-based-methods">
<a class="anchor" href="#actor-critic-based-methods" aria-hidden="true"><span class="octicon octicon-link"></span></a>ACTOR-CRITIC BASED METHODS</h2>

<p>This group of methods tries to use actor-critic architecture to do centralised training and decentralised execution. Usually, they use the full state and additional information which are available in the training phase in the critic network to generate a richer signal for the actor.</p>

<h3 id="maddpg">
<a class="anchor" href="#maddpg" aria-hidden="true"><span class="octicon octicon-link"></span></a>MADDPG</h3>

<p>Multi-Agent DDPG (MADDPG) is a method to use separate actors and critics for each agent and train the critic in a centralised way and use the actor in execution. So each agent has one actor and one critic. The actor has access to its own action-observation data and is trained by them and the critic has access to observation and action of all agents and is trained by all of them.</p>

<p><img src="/blog/images/posts_images/ddpg_post/maddpg.png" alt="MADDPG" title=" source: https://arxiv.org/pdf/1706.02275.pdf "></p>

<p>The centralised action-value function for each agent can be written as:</p>

<p><img src="/blog/images/posts_images/ddpg_post/maddpg2.png" alt="MADDPG"></p>

<p>And the gradient can be written as follows:</p>

<p><img src="/blog/images/posts_images/ddpg_post/maddpg3.png" alt="MADDPG"></p>

<p>As you see, the policy is conditioned on the observation of the agent itself, o_i, and the critic is conditioned on the full state and actions of all agents.
This separate critic for each agent allows us to have agents with different rewards, cooperative or competitive behaviors.</p>

<h3 id="coma">
<a class="anchor" href="#coma" aria-hidden="true"><span class="octicon octicon-link"></span></a>COMA</h3>

<p>The talk can be found \href{https://www.youtube.com/watch?v=3OVvjE5B9LU}{here}.</p>

<p>Counterfactual Multi-Agent (COMA) policy gradient is a method for cooperative multi-agent systems and uses a centralised critic to estimate the Q-function and decentralised actors to optimise the agents’ policies. In addition, to address the problem of multi-agent credit assignment, it uses a counterfactual baseline that marginalises out a single agent’s action, while keeping the other agents’ actions fixed. The idea comes from difference rewards, in which each agent learns from a shaped reward D_a = r(s, u) − r(s,(u^-a, c_a)) that compares the global reward to the reward received when the action of agent a is replaced with a default action c_a.</p>

<p>COMA also uses a critic representation that allows the counterfactual baseline to be computed efficiently in a single forward pass.</p>

<p><img src="/blog/images/posts_images/ddpg_post/coma.png" alt="COMA" title=" source: https://www.aaai.org/ocs/index.php/AAAI/AAAI18/paper/viewPaper/17193 "></p>

<p>For each agent a, we can then compute an advantage function that compares the Q-value for the current action u^a to a counterfactual baseline that marginalizes out u^a, while keeping the other agents’ actions u^-a fixed:</p>

<p><img src="/blog/images/posts_images/ddpg_post/coma2.png" alt="COMA"></p>

<p>In contrast to MADDPG, COMA is an on-policy approach and has only one critic network.</p>


  </div><!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="kargarisaac/blog"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/blog/rl/2020/06/15/online-rl.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/blog/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/blog/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>My posts about Machine Learning</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/kargarisaac" title="kargarisaac"><svg class="svg-icon grey"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://twitter.com/kargarisaac" title="kargarisaac"><svg class="svg-icon grey"><use xlink:href="/blog/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
