<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="https://kargarisaac.github.io/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://kargarisaac.github.io/blog/" rel="alternate" type="text/html" /><updated>2020-10-21T09:28:20-05:00</updated><id>https://kargarisaac.github.io/blog/feed.xml</id><title type="html">Isaac Kargar</title><subtitle>My posts about Machine Learning</subtitle><entry><title type="html">RL algorithms</title><link href="https://kargarisaac.github.io/blog/rl/2020/06/15/rl-series-ddpg.html" rel="alternate" type="text/html" title="RL algorithms" /><published>2020-06-15T00:00:00-05:00</published><updated>2020-06-15T00:00:00-05:00</updated><id>https://kargarisaac.github.io/blog/rl/2020/06/15/rl-series-ddpg</id><content type="html" xml:base="https://kargarisaac.github.io/blog/rl/2020/06/15/rl-series-ddpg.html">&lt;h1 id=&quot;rl-algorithms&quot;&gt;RL Algorithms&lt;/h1&gt;

&lt;p&gt;In this post I will overview different single and multi-agent Reinforcement Learning (RL) algorithms. I will update this post and add algorithms periodically.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/posts_images/rl-series/rl-diagram.png&quot; alt=&quot;RL diagram&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;single-agent&quot;&gt;Single agent&lt;/h2&gt;

&lt;h3 id=&quot;dqn&quot;&gt;DQN&lt;/h3&gt;

&lt;h3 id=&quot;reinforce&quot;&gt;Reinforce&lt;/h3&gt;

&lt;h3 id=&quot;a2c&quot;&gt;A2C&lt;/h3&gt;

&lt;h3 id=&quot;a3c&quot;&gt;A3C&lt;/h3&gt;

&lt;h3 id=&quot;ppo&quot;&gt;PPO&lt;/h3&gt;

&lt;h3 id=&quot;ddpg&quot;&gt;DDPG&lt;/h3&gt;

&lt;p&gt;This algorithm is from the &lt;em&gt;“Continuous Control with Deep Reinforcement Learning”&lt;/em&gt; &lt;a href=&quot;https://arxiv.org/pdf/1509.02971.pdf&quot;&gt;paper&lt;/a&gt; and uses the ideas from deep q-learning in the continuous action domain and is a model-free method based on the deterministic policy gradient.&lt;/p&gt;

&lt;p&gt;In Deterministic Policy Gradient (DPG), for each state, we have one clearly defined action to take (the output of policy is one value for action and for exploration we add a noise, normal noise for example, to the action). But in Stochastic Gradient Descent, we have a distribution over actions (the output of policy is mean and variance of a normal distribution) and sample from that distribution to get the action, for exploration. In another term, in stochastic policy gradient, we have a distribution with mean and variance and we draw a sample from that as an action. When we reduce the variance to zero, the policy will be deterministic.&lt;/p&gt;

&lt;p&gt;When the action space is discrete, such as q-learning, we get the max over q-values of all actions and select the best action. But in continuous action spaces, you cannot apply q-learning directly, because in continuous spaces finding the greedy policy requires optimization of a_t at every time-step and would be too slow for large networks and continuous action spaces. Based on the proposed equation in the reference paper, here we approximate max Q(s, a) over actions with Q(a, µ(s)).&lt;/p&gt;

&lt;p&gt;In DDPG, they used function approximators, neural nets, for both action-value function Q and deterministic policy function µ. In addition, DDPG uses some techniques for stabilizing training, such as updating the target networks using soft updating for both μ and Q. It also uses batch normalization layers, noise for exploration, and a replay buffer to break temporal correlations.&lt;/p&gt;

&lt;p&gt;This algorithm is an actor-critic method and the network structure is as follows:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/posts_images/ddpg_post/ddpg_diagram.jpg&quot; alt=&quot;DDPG diagram&quot; /&gt;&lt;/p&gt;

&lt;p&gt;First, the policy network gets the state and outputs the action mean vector. This will be a vector of mean values for different actions. For example, in a self-driving car, there are two continuous actions: steering and acceleration&amp;amp;braking (one continuous value between -x to x, the negative values are for braking and positive values are for acceleration). So we will have two mean for these two actions. To consider exploration, we can use Ornstein-Uhlenbeck or normal noise and add it to the action mean vector in the training phase. In the test phase, we can use the mean vector directly without any added noise. Then this action vector will be concatenated with observation and fed into the Q network. The output of the Q network will be one single value as a state-action value. In DQN, because it had discrete action space, we had multiple state-action values for each action, but here because the action space is continuous, we feed the actions into the Q network and get one single value as the state-action value.&lt;/p&gt;

&lt;p&gt;Finally, the sudo code for DDPG is as follows:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/images/posts_images/ddpg_post/ddpg_algorithm.jpg&quot; alt=&quot;&quot; title=&quot;DDPG algorithm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To understand the algorithm better, it’s good to try to implement it and play with its parameters and test it in different environments. Here is a good implementation in PyTorch that you can start with &lt;a href=&quot;https://github.com/higgsfield/RL-Adventure-2/blob/master/5.ddpg.ipynb&quot;&gt;this&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I also found the Spinningup implementation of DDPG very clear and understandable too. You can find it &lt;a href=&quot;https://github.com/openai/spinningup/blob/master/spinup/algos/pytorch/ddpg/ddpg.py&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;For POMDP problems, it is possible to use LSTMs or any other RNN layers to get a sequence of observations. It needs a different type of replay buffer for sequential data.&lt;/p&gt;

&lt;h3 id=&quot;sac&quot;&gt;SAC&lt;/h3&gt;

&lt;h3 id=&quot;ape-x&quot;&gt;Ape-X&lt;/h3&gt;

&lt;h3 id=&quot;r2d2&quot;&gt;R2D2&lt;/h3&gt;

&lt;h3 id=&quot;impala&quot;&gt;IMPALA&lt;/h3&gt;

&lt;h3 id=&quot;never-give-up&quot;&gt;Never Give-Up&lt;/h3&gt;

&lt;h3 id=&quot;agent57&quot;&gt;Agent57&lt;/h3&gt;

&lt;h2 id=&quot;multi-agent&quot;&gt;Multi-Agent&lt;/h2&gt;

&lt;h3 id=&quot;maddpg&quot;&gt;MADDPG&lt;/h3&gt;

&lt;h3 id=&quot;coma&quot;&gt;COMA&lt;/h3&gt;</content><author><name></name></author><summary type="html">RL Algorithms</summary></entry><entry><title type="html">AlphaGo - Mastering the game of Go with deep neural networks and tree search</title><link href="https://kargarisaac.github.io/blog/jupyter/2020/04/12/AlphaGo.html" rel="alternate" type="text/html" title="AlphaGo - Mastering the game of Go with deep neural networks and tree search" /><published>2020-04-12T00:00:00-05:00</published><updated>2020-04-12T00:00:00-05:00</updated><id>https://kargarisaac.github.io/blog/jupyter/2020/04/12/AlphaGo</id><content type="html" xml:base="https://kargarisaac.github.io/blog/jupyter/2020/04/12/AlphaGo.html">&lt;!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2020-04-12-AlphaGo.ipynb
--&gt;

&lt;div class=&quot;container&quot; id=&quot;notebook-container&quot;&gt;
        
    
    
&lt;div class=&quot;cell border-box-sizing code_cell rendered&quot;&gt;

&lt;/div&gt;
    

&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/kargarisaac/blog/blob/master/_notebooks/my_icons/alphago/alphago_0.png?raw=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/kargarisaac/blog/blob/master/_notebooks/my_icons/alphago/alphago_1.jpeg?raw=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/kargarisaac/blog/blob/master/_notebooks/my_icons/alphago/alphago_2.jpeg?raw=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/kargarisaac/blog/blob/master/_notebooks/my_icons/alphago/alphago_3.jpeg?raw=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/kargarisaac/blog/blob/master/_notebooks/my_icons/alphago/alphago_4.jpeg?raw=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/kargarisaac/blog/blob/master/_notebooks/my_icons/alphago/alphago_5.jpeg?raw=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/kargarisaac/blog/blob/master/_notebooks/my_icons/alphago/alphago_6.jpeg?raw=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/kargarisaac/blog/blob/master/_notebooks/my_icons/alphago/alphago_7.jpeg?raw=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/kargarisaac/blog/blob/master/_notebooks/my_icons/alphago/alphago_8.jpeg?raw=1&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cell border-box-sizing text_cell rendered&quot;&gt;&lt;div class=&quot;inner_cell&quot;&gt;
&lt;div class=&quot;text_cell_render border-box-sizing rendered_html&quot;&gt;
&lt;p&gt;That’s it for the first one. In the next post, I will review the AlphaGo Zero paper.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name>Isaac Kargar</name></author><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://kargarisaac.github.io/blog/_notebooks/my_icons/alphago/alphago_0.png" /><media:content medium="image" url="https://kargarisaac.github.io/blog/_notebooks/my_icons/alphago/alphago_0.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>